# 35-事务传播行为

指的是外部方法1调用了事务2，此时【事务2的提交、回滚逻辑】，是针对声明式事务的概念，**注意！！！传播行为是声明在【事务2】上的**。

1. 默认是REQUIRED，如果方法1没有事务，事务2会单独开启一个事务。如果方法1有事务，事务2会融入方法1的事务，两者视为一个整体事务。

2. SUPPORTS，和REQUIRED差不多，区别是方法1没有事务的话，方法2就不开启事务。【严格按照外部方法的标准执行】。

3. REQUIRED_NEW，不管方法1有没有事务，事务2都会单独开启。也就是说事务2和外部方法的事务没有关联，各自进行提交回滚。

   ​	

   

4. NOT_SUPPORTED，方法1没事务，事务2不会开启。方法1有事务，事务2单独开启。和REQUIRED_NEW有点类似，也是各自提交回滚。

5. NEVER，方法1没事务，事务2不开启。方法1有事务，事务2抛异常。就是不想两个事务有共同发生。

6. MANDATORY，方法1没事务，事务2抛异常。方法1有事务，事务2融入方法1的事务。就是必须依赖外部的事务，自己才会执行。

7. NESTED，方法1没事务，事务2单独开启。方法1有事务，事务2融入，但事务1的异常会导致事务2回滚，事务2不会导致事务1回滚（外影响内，内不影响外）。

# 36-Spring事务的实现原理	

和AOP类似，需要@EnableTransactionManagement才能够使用声明式事务。

其实整个Spring事务的实现，可以理解为就是AOP的实现。也是经历这么三步：

1. 全局解析切面、切点，生成advisor。

2. AOP创建（初始化阶段或循环依赖阶段）的时候看看这个SB时候命中adviosr的切点，命中的话就创建动态代理。但是这里的advisor是@EnableTransactionManagement帮我们引入了，毕竟我们没有专门为声明式事务创建切面或切点。这个advisor会命中那些使用了@Transactional的SB，并为这些方法创建环绕通知的动态代理。

3. 实际的增强逻辑是这样的：

   ```java
   try{
       // 创建或获取数据库连接，设置autocommit=false
       // 开启事务
       // 执行被代理的原方法
       // 提交事务
   }catch(Exception e){
       // 回滚事务
   }
   ```

# 37-事务传播行为的实现原理

总的来说是基于ThreadLocal来控制，如果需要融入，则直接使用ThreadLocal存放的外部事务的数据库连接。如果需要派生，则将ThreadLocal里的数据库连接置空，并用一个指针将这个数据库连接保存起来。然后内部事务新创建一个数据库连接，进行内部事务的逻辑。内部事务结束后，会将刚才暂存的外部事务连接放回ThreadLocal中，返回给外部方法继续使用（今晚完善笔记）。

我觉得想说明白这个实现原理，先得明白两个概念：1. 事务的传播行为都是基于同一个线程的，不会说从一个线程的事务传播到另外一个线程的事务 2.事务的行为都是基于TransactionInfo的newTransaction属性来判断【当前事务是不是一个新事务】。

# 38-如何实现多线程的Spring事务一致性

知识点37已经说过了，在声明式事务中都是只有1个线程来进行事务。其实可以通过编程式事务 + XA最终一致性来完成多线程事务，当然线程之间的通信机制就得考虑如何实现了。

# 39-Spring事务的失效原因

其实和AOP的失效一样，如本类中多个@Transactional之间的互相调用，被调用的事务是不会生效的。当然，还有其他奇怪的原因比如数据库引擎不支持事务、异常被catch处理了等等。

# 40-Spring事件的核心机制

其实事件有点类似MQ和Go语言的channel，无非就是消费者和生产者模型的东西，只不过Spring事件是限定在一个IOC容器内的生产与消费，看起来用处不大，其实在Spring源码里，以及其他框架（例如Apollo）集成Spring会经常用到事件这一特性。

事件的原理是基于观察者这一设计模式。主要有3部分组成：

1. 事件（生产资料）
2. 监听器（消费者）
3. 事件发生器（生产者）

事件的发布一般是同步的，必须要等监听器消费完，当然也可以异步。

# 41-Spring的常用设计模式

其实可以分场景来看的，比如

1. SB的生成：工厂模式与单例模式
2. AOP的生成：代理模式
3. 事件：观察者模式
4. Bean定义的创建：策略模式
5. AOP的方法调用：责任链模式
