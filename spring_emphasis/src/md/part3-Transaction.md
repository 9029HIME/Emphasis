# 35-事务传播行为

指的是外部方法1调用了事务2，此时【事务2的提交、回滚逻辑】，是针对声明式事务的概念，**注意！！！传播行为是声明在【事务2】上的**。

1. 默认是REQUIRED，如果方法1没有事务，事务2会单独开启一个事务。如果方法1有事务，事务2会融入方法1的事务，两者视为一个整体事务。

2. SUPPORTS，和REQUIRED差不多，区别是方法1没有事务的话，方法2就不开启事务。【严格按照外部方法的标准执行】。

3. REQUIRED_NEW，不管方法1有没有事务，事务2都会单独开启。也就是说事务2和外部方法的事务没有关联，各自进行提交回滚。

   ​	

   

4. NOT_SUPPORTED，方法1没事务，事务2不会开启。方法1有事务，事务2单独开启。和REQUIRED_NEW有点类似，也是各自提交回滚。

5. NEVER，方法1没事务，事务2不开启。方法1有事务，事务2抛异常。就是不想两个事务有共同发生。

6. MANDATORY，方法1没事务，事务2抛异常。方法1有事务，事务2融入方法1的事务。就是必须依赖外部的事务，自己才会执行。

7. NESTED，方法1没事务，事务2单独开启。方法1有事务，事务2融入，但事务1的异常会导致事务2回滚，事务2不会导致事务1回滚（外影响内，内不影响外）。

# 36-Spring事务的实现原理	

和AOP类似，需要@EnableTransactionManagement才能够使用声明式事务。

其实整个Spring事务的实现，可以理解为就是AOP的实现。也是经历这么三步：

1. 全局解析切面、切点，生成advisor。

2. AOP创建（初始化阶段或循环依赖阶段）的时候看看这个SB时候命中adviosr的切点，命中的话就创建动态代理。但是这里的advisor是@EnableTransactionManagement帮我们引入了，毕竟我们没有专门为声明式事务创建切面或切点。这个advisor会命中那些使用了@Transactional的SB，并为这些方法创建环绕通知的动态代理。

3. 实际的增强逻辑是这样的：

   ```java
   try{
       // 创建或获取数据库连接，设置autocommit=false
       // 开启事务
       // 执行被代理的原方法
       // 提交事务
   }catch(Exception e){
       // 回滚事务
   }
   ```

# 37-事务传播行为的实现原理

总的来说是基于ThreadLocal来控制，如果需要融入，则直接使用ThreadLocal存放的外部事务的数据库连接。如果需要派生，则将ThreadLocal里的数据库连接置空，并用一个指针将这个数据库连接保存起来。然后内部事务新创建一个数据库连接，进行内部事务的逻辑。内部事务结束后，会将刚才暂存的外部事务连接放回ThreadLocal中，返回给外部方法继续使用（今晚完善笔记）。

我觉得想说明白这个实现原理，先得明白两个概念：1. 事务的传播行为都是基于同一个线程的，不会说从一个线程的事务传播到另外一个线程的事务 2.事务的行为都是基于TransactionInfo的newTransaction属性来判断【当前事务是不是一个新事务】。

