# 不要以为send()就万事大吉了

如果业务线程调用send()方法发送一条消息，这条消息经过Interceptor、Serializer、Partitioner处理后到达RecordAccumulator后，send()级成功返回了，消息剩下的流转交给sender线程进行。也就是说，**Kafka Producer的send()本质是异步的，当send()调用成功后，消息本质是在Producer的内存里，而不是发送给Broker，如果将send()结束视为“发送成功”就可能会丢失消息。**

那有什么办法可以保证消息的可靠性呢？同步发送或异步回调可以实现，如果采用同步发送：

```java
try {
    RecordMetadata metadata = producer.send(record).get();
} catch (Exception e) {
    // 处理异常，如记录日志、发送通知等
}
```

当调用send().get()后，业务线程会阻塞直到Broker响应ack（**即ProduceResponse，下面会介绍** ），我可以根据调用get()是否抛异常来判断消息是否发送成功。如果采用异步发送：

```java
producer.send(record, new Callback() {
    @Override
    public void onCompletion(RecordMetadata metadata, Exception exception) {
        if (exception == null) {
            
        } else {
            // 处理异常，如记录日志、发送通知等
        }
    }
});
```

在调用send()后，onCompletion()的逻辑会在Broker响应ack后执行，我可以通过exception是否为null来判断消息是否发送成功。值得注意的是，**onCompletion()的逻辑是由sender线程执行的，如果比较耗时有可能会导致`消息发送`与`其他消息的回调`执行阻塞。** 

不管是同步发送还是异步发送，最好在业务层面控制好消息的发送状态，比如：

1. 同步发送成功后将状态改为`发送成功`。
2. 异步发送后将状态改为`发送中`，异步回调后将状态改为`发送成功`。

而不是简单地调用了send()就认为`发送成功`，虽然发生概率的问题不大，可一旦发生将会导致数据的不一致。

# ProducerRecord的流转

一条消息的本质是ProducerRecord。通过业务线程调用send()发送后，ProducerRecord先经过Interceptor进行拦截处理、再经过Serializer进行序列化、最后被Partitioner确定最终发给哪个Partition Leader，然后被放进RecordAccumulator的InFlightBatch的RecordBatch里（也就是Dqueue）里，此时业务线程的发送行为就结束了。

当RecordBatch的阈值触发后，比如最大停留时间（queue.buffering.max.ms）、最大数据量（batch.num.messages）就会将多个RecordBatch打包成1个Request放进InFlightRequests队列里，最终达到max.in.flight.requests.per.connection的值，并按照FIFO的顺序从InFlightRequests里发送Request给Broker，然后等待Broker的ack，sender根据ack再确定是重发还是清除掉**InFlightBatch里的RecordBatch和InFlightRequests里的Request**。

![01](02-再到生产者.assets/01.png)

这张图在我之前的笔记里出现过，当时引出了一个问题：它们之间的ER关系是什么？接下来解答以下：

1. 1个Producer 对应 1个RecordAccumulator。
2. 1个InflightBatch 对应 1个Partition Leader。
3. 1个inFlightBatch包含了多个RecordBatch，1个RecordBatch包含了多条ProducerRecord（消息）。
4. 1个InFlightRequest 对应 1个Broker。1个InFlightRequest里包含max.in.flight.requests.per.connection个Request。

**也就是说：1个Request包含了多个不同Parition Leader的RecordBatch**，这个关系有些坑在下面的两个章节介绍。

# Request与SequenceNumber

# Request与ProduceResponse

# 有序性没那么简单

# 重试与兜底

# 元数据的一致性