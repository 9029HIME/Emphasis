# 1.为什么Redis那么快

1. 最主要还是因为Redis的操作是基于内存的，除了持久化之外不会涉及磁盘IO，而且作为KV存储结构，底层用的是哈希表，哈希表就是典型的快查询数据结构。
2. 其次Redis采用了单线程进行读写的设计，使用了IO多路复用的机制，减少了多线程切换和锁竞争的时间成本。
3. 虽然采用了单线程就意味着请求很容易因为其他请求的慢处理而阻塞，但Redis对单一请求的处理速度还是挺快的，除了del一个很长的链表数据外，基本没什么问题。

# 2-缓存穿透的解决

穿透的本质：大量请求打到Redis找一个key，刚好这个key过时了，于是这些请求都打到数据库上，短时间内数据库承受了大量的请求。这种情况下可能会导致数据库挂掉。

1. 在接口层尽量对参数做校验，避免一些本来就没值请求到缓存或数据库。
2. 当发现缓存取不到数据，数据库也拿不到数据时，可以将这个Key对应的值设为Null，然后存在缓存里，避免后续的请求打进数据库。
3. 在缓存前面加一层布隆过滤器，发现请求的数据不命中布隆过滤器后，不再请求下去。

# 3-主从同步过程

1. 保存主节点元数据
2. 建立Socket连接
3. 发送Ping命令
4. 权限校验
5. 全量复制
6. 持续增量复制

# 4-哨兵

虽然主从同步可以实现读写分离，但哨兵能增加一个“监控”与“故障转移”的功能，并且客户端连接哨兵即可实现分离，不需要单独连接主和从。

# 5-Redis事务

其实Redis的事务和MySQL一样都遵循着ACID原则，只不过Redis的ACID里的A没有“回滚机制”，一旦失败了则持久到最近一条成功命令的状态。

1. （可选）客户端发送watch命令，可以在事务执行前对这个key执行watch操作，当事务exec之前其他客户端对这个key修改后，客户端执行exec命令后会返回错误信息，并且不执行这个事务。
2. 客户端发送multi命令，Redis-Server将这个客户端标识为REDIS-MULTI=true。
3. 客户端命令到达Redis-Server后，并不会立即执行，而是将这些命令入队（排除掉multi、exec、watch、discard）。检查【命令语法】是否正确，如果不正确Redis-Server将这个客户端标识为REDIS-MULTI=false，并返回错误信息。如果正确，对于这个命令返回QUEUED回复。
4. 客户端发送exec命令，Redis-Server做完前置检查后（判断事务标识是否为true，客户端watch后key是否脏了），遍历这个客户端的事务命令队列，依次执行，最终将返回结果全部返回给客户端。