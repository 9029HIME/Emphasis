 # 1.为什么Redis那么快

1. 最主要还是因为Redis的操作是基于内存的，除了持久化之外不会涉及磁盘IO，而且作为KV存储结构，底层用的是哈希表，哈希表就是典型的快查询数据结构。
2. 其次Redis采用了单线程进行读写的设计，使用了IO多路复用的机制，减少了多线程切换和锁竞争的时间成本。
3. 虽然采用了单线程就意味着请求很容易因为其他请求的慢处理而阻塞，但Redis对单一请求的处理速度还是挺快的，除了del一个很长的链表数据外，基本没什么问题。

# 2-缓存击穿和缓存雪崩的解决

击穿的本质：大量请求打到Redis找一个key，刚好这个key过时了，于是这些请求都打到数据库上，短时间内数据库承受了大量的请求。这种情况下可能会导致数据库挂掉。

雪崩的本质：大面积的缓存击穿，即许多key在同一段时间内失效了。

1. 在接口层尽量对参数做校验，避免一些本来就没值请求到缓存或数据库。
2. 当发现缓存取不到数据，数据库也拿不到数据时，可以将这个Key对应的值设为Null，然后存在缓存里，避免后续的请求打进数据库。
3. 在缓存前面加一层布隆过滤器，发现请求的数据不命中布隆过滤器后，不再请求下去。

# 3-主从同步过程

1. 保存主节点元数据
2. 建立Socket连接
3. 发送Ping命令
4. 权限校验
5. 全量复制
6. 持续增量复制

# 4-哨兵

虽然主从同步可以实现读写分离，但哨兵能增加一个“监控”与“故障转移”的功能，并且客户端连接哨兵即可实现分离，不需要单独连接主和从。

# 5-Redis事务

其实Redis的事务和MySQL一样都遵循着ACID原则，只不过Redis的ACID里的A没有“回滚机制”，一旦失败了则持久到最近一条成功命令的状态。

1. （可选）客户端发送watch命令，可以在事务执行前对这个key执行watch操作，当事务exec之前其他客户端对这个key修改后，客户端执行exec命令后会返回错误信息，并且不执行这个事务。
2. 客户端发送multi命令，Redis-Server将这个客户端标识为REDIS-MULTI=true。
3. 客户端命令到达Redis-Server后，并不会立即执行，而是将这些命令入队（排除掉multi、exec、watch、discard）。检查【命令语法】是否正确，如果不正确Redis-Server将这个客户端标识为REDIS-MULTI=false，并返回错误信息。如果正确，对于这个命令返回QUEUED回复。
4. 客户端发送exec命令，Redis-Server做完前置检查后（判断事务标识是否为true，客户端watch后key是否脏了），遍历这个客户端的事务命令队列，依次执行，最终将返回结果全部返回给客户端。

# 6-九大Redis数据结构

日常开发主要用五种：String、List、Set、Hash、Sorted Set。当然实际开发中最常打交道的还是String

除了这五种外，还有四种比较少用：bitmap（做布隆过滤器）、geohash、HyperLogLog、Streams。

# 7-Redis分布式锁的问题

早期是setnx + setex，先用setnx保证只有1个请求成功上锁，再用setex给锁加上超时时间。这两个操作是分开执行的，有并发安全问题。

后期合并了这两个命令，改用set(key,value,nx,px)，保证只有1个请求成功上锁并设置超时时间。

即使是这样，还是有一些问题

1. A拿锁成功，结果任务太久了，超出了锁的存在时间。此时B拿锁成功，B也开启相同的任务。结果A在结束后解的是B的锁。可以使用redisson的看门狗机制和自动续费来解决。
2. 不可重入，可以使用redisson解决。
3. 主从复制的时候可能会导致锁丢失，主节点宕机，从节点没来得及同步锁就成了新主节点。B在新主节点上锁成功，然后开启相同的任务。可以通过红锁redlock的方式避免。

# 8-过期Key的删除策略

Redis有一个expires字典，专门存放设置了ttl的key。这个字典的key是指向ttl-key的指针，value是过期时间。

1. 惰性删除

   只有访问一个key时（包括setnx）才会判断key是否过期，过期则删除，这种策略能够节省CPU资源，增加请求处理效率。但也增加了内存负担。

2. 定期删除

   每隔一段时间扫描【一定数量的】expires字典中的【一定数量的】key，从中清除已过期的key。这种策略对内存比较友好，但Redis线程需要专门空余出来做这件事，会消耗一定的性能，可以通过【调整扫描间隔】和【限定扫描耗时】来达到平衡效果。

实际上，Redis同时使用了这两种方式。

# 9-缓存穿透

击穿是大量请求不命中缓存，从而找数据库，雪崩指的是大范围的击穿。缓存穿透则是更细致的情况：不命中缓存去找数据库，结果数据库也没有。

基本解决思路和击穿差不多。
