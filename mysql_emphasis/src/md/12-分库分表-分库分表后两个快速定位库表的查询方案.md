# 背景

在分库分表的场景下，一般会采用全库查询，通过代理中间件从所有分库中查询出子结果，在代理层汇聚成最终结果，响应给客户端。如需要查询username = 'kjg'的用户，代理中间件会从各个子库中查询 SELECT * FROM t WHERE username = 'kjg'，然后返回给客户端。

这种方案需要考虑索引的命中率，否则会引起多库全表扫描。但不管怎么查，全库查询需要操作所有子库，这是一个相对低效的方案，因此需要一个**能快速定位查询数据在哪一个库的解决方案**。

# 基因法（高效，但影响分库分表方案）

## 分库分表过程

想要使用基因法来快速查询数据，前提是**要满足基因法的分库分表策略**。它的分库分表策略是这样的：

0. 假设用户表有三个字段：id、username、password，需要对这个表确定一个**基因字段**，现在设定username字段为基因字段。

1. 新增用户的时候，对username进行一套hash算法，并转为2进制数据，假设kjg的二进制数据为 100101010.............0010。

   ![image-20221109134050071](markdown-img/12-分库分表-分库分表后两个快速定位库表的查询方案.assets/image-20221109204050071.png)

2. 算出以2为底数，MySQL主节点数量N的对数log2N，假设MySQL主节点数量是4，那么对数的值为2

3. 取二进制数的最后2位，作为kjg这行数据，实际存储的MySQL主节点序号。此时kjg要存储在2号主节点上。

   ![image-20221109134541351](markdown-img/12-分库分表-分库分表后两个快速定位库表的查询方案.assets/image-20221109204541351.png)

   

4. id的值不能再依赖分布式ID了，假如id是bigint类型，则取二进制数的前62位 + 最后2位，再转换为10进制，得到最终的id值。

## 查询过程

采用基因法进行分库后，接下来对**基因字段**的查询就非常地便捷了：

1. 代码需要查询username = 'kjg'的数据
2. 采用同样的hash算法 + 二进制转换，得到kjg的最后两位数字10
3. 通过10，定位到kjg所在的数据库是2号数据库
4. 代码直接从2号数据库查询username = 'kjg'的数据

## 适用场景

基因法的缺点比较明显，最主要是占用了分库分表方案，如果想采用其他方案如递增条件、hash、一致性hash就不兼容了。并且基因法的特性，也带来节点扩容难的问题，最理想的情况下是**提前定义好足够的2的n次幂台数据库节点**，再使用基因法。当然，不是2的n次幂也可以，代码能做好兼容二进制定位到不存在的数据库节点问题，也是可以使用基因法的。而且作为基因分库的核心算法：二进制算法，需要一套独立性很强，碰撞性低的算法，否则会出现**重复主键**的问题。

但是基因法的优点也很突出，它适合一些**特定条件（基因条件）**以及**主键**下的快速查询，效率非常地快。如果是特定字段下的快速查询场景，很适合使用基因法来做，当然也得考虑缺点的取舍。

# 倒排索引法（高效，但很吃内存）

## 新增过程

参考了Elasticsearch的倒排索引，这套方案能够**兼容其他分库分表策略**。具体过程是新增数据后，通过代码侵入或者其他方式，在Redis也维护一个倒排索引。假设我新增username = 'kjg'的数据

1. 通过特定分库分表策略，往主节点插入数据，并获得主节点的ID
2. 将username@kjg作为key，主节点ID作为value，存入Redis

也可以视情况，将其他条件也作为key、主节点作为value，存入Redis。甚至可以直接采用Elasticsearch来替代Redis，存储整个倒排索引。

## 查询过程

1. 代码拼接username@kjg字符串，作为key查询Redis，找到数据所在的主节点ID
2. 代码从主节点ID查询username = 'kjg'的数据

## 适用场景

性能比基因法稍弱（要先查一次Redis或Es），但是不会影响原有的分库分表策略，且支持多个特定条件的快速查询（只需新增的时候维护好倒排索引即可）。

但特定条件需要发生更改的话，需要考虑倒排索引与数据库的一致性问题。而且数据量大的情况下，Redis需要消耗大量内存来存储倒排索引，服务器成本需要考量。
