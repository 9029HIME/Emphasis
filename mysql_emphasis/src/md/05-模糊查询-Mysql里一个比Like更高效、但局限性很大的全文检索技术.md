# 什么是n

了解ngram之前，首先需要了解n是什么，它指的是对一串文本的分割单位，假设文本是“你好我叫黄俊严”。如果用n=2对这段文本进行分割，那么能分割出“你好”、“我叫”、“黄俊”、“严”这4个字符串。假设n=3，那么能区分出“你好我”、“叫黄俊”、“严”这3个字符串。这些被分出来的字符串叫做分词，也叫字条。

此时这和Elasticsearch的“词条”没什么区别，只不过ES支持更多和分词器，甚至可以自定义分词器。而MySQL的ngram仅支持基于固定字符串长度进行分词。

# 什么是ngram

ngram就是在n的基础上，mysql对某个字段的值进行分词，然后通过倒排索引进行存储，当模糊查询命中这些分词的时候，就能命中分词对应的行记录值。但是对于MySQL来说，ngram的n属于一个配置值，是固定写死的，**因此局限性比较大**。以“你好我叫黄俊严”这条id=5的行记录为例，如果n=2的话，倒排索引如下：

|      | id   |
| ---- | ---- |
| 你好 | 1    |
| 我叫 | 1    |
| 黄俊 | 1    |
| 严   | 1    |

这个其实和Elasticsearch的倒排索引没多大区别。

# 如何使用ngram

ngram的定义体现在DDL上，假设我需要对title字段建立ngram索引，那么在DDL必须声明

FULLTEXT INDEX \`索引名\`(\'title\') WITH PARSER 'ngram'

并且想要命中ngram，就得严格命中分词的值，比如WHERE MATCH(title) AGAINST ('你好')，才能找到上面id=1的值。如果是WHERE MATCH(title) AGAINST ('你')，则不会命中。

# ngram的局限性

其实ngram的倒排索引和elasticsearch差不多，使用得当还是能代替LIKE的，并且比LIKE还高效。但由于n是固定的数值，没有一个比较好的自定义分词器来替代，所以ngram只适用于长度较短、并且查询条件简单的场景，实在太复杂还是考虑elasticsearch吧。