# 索引下推

作用：默认在8.x版本开启，在复合索引的前提下，能够减少回表查询。

命中索引下推时，Extra会显示“Using index condition”。

## 案例

定义表结构：

```sql
CREATE TABLE `t_t_table` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `a` int(11) DEFAULT NULL,
  `b` varchar(255) DEFAULT NULL,
  `c` int(11) DEFAULT NULL,
  `d` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `idx_a_b` (`a`,`b`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
```

关键sql：

```sql
SELECT * FROM t_t_table WHERE a = 17 and b LIKE '%xxx'
```

上面这条sql，一眼就能看出无法命中复合索引idx_a_b的b字段，只能命中a字段。

在开启索引下推的前提下（SET optimizer_switcher = 'index_condition_pushdown=on'），执行这条语句的耗时是8ms。

关闭索引下推后（SET optimizer_switcher = 'index_condition_pushdown=off'），这条语句的耗时是27 - 100ms。

## 原理

那么这个索引下推，到底做了什么呢？先看一下关闭索引下推，语句的执行过程：

1. 从索引idx_a_b找到a=17的主键值。
2. 根据主键值，在主键索引找到记录，并根据 b LIKE '%xxx'进行条件判断。
3. 得到最终的结果值。

如果开启了索引下推，语句的执行过程就变成：

1. 从索引idx_a_b找到a=17的叶子节点。
2. 在叶子节点根据b LIKE '%xxx'进行条件判断，获取符合条件的主键值。
3. 根据主键值，在主键索引找到记录。
4. 得到最终的结果值。

可以看到，索引下推的优化本质是：在复合索引进行条件判断，得到最终的主键值再回表，**而不是先回表再条件判断**。
