# 索引选择性差

有时候明明应该命中索引，MySQL却帮它优化掉了，反而走全表扫描，这是因为索引选择性太差了。

比如模糊查询值**太过模糊**，或者索引重复性，MySQL不会选择走索引，从而减少不必要的回表查询。有一种说法是：命中的索引值如果超过数据总量的25%，那么MySQL是不会选择索引的（待考究）。

# 如何解决索引选择性差导致的性能问题

1. 引入其他字段，命中辅助索引

   以 SELECT * FROM 医生表 WHERE 性别 = '女';为例

   像性别这种字段，本身重复性就很高，此时是不会命中索引的，可以考虑新增一个字段参与查询，比如

   SELECT * FROM 医生表 WHERE 科室 = ‘内科’ AND 性别 = '女'

   像这样，通过命中科室索引来提升SQL效率

2. 使用ES替代

   如果只能选择性别为女的医生，并且不允许加入辅助索引，那么可以采用ES替代MySQL的查询，不过得考虑数据一致性问题，比较适合高可用弱一致性的场景。

3. force index(性别)

   使用SELECT * FROM 医生表 FORCE INDEX('性别') WHERE 性别 = '女';

   告诉MySQL强制使用索引，但不能保证100%比不走索引要好，需要实际测试。

4. 增加缓存，从而提高全表扫描的能力

   兜底摆烂做法，通过堆硬件的方式强行解决性能问题。



