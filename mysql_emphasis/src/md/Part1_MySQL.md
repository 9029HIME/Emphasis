# 1-B树与B+树

![image](https://user-images.githubusercontent.com/48977889/179526717-8ed8a911-915d-4e3b-a93c-cb112625efe1.png)

![image](https://user-images.githubusercontent.com/48977889/179526639-83d39411-f929-407b-a212-260715c5dc24.png)

1. 首先它们的节点都是排好序的，并且它们的**中序遍历**结果是递增的。
2. B树一个节点最多有2个叶子节点，B+树一个节点最多有3个叶子节点。
3. B+树有个特点，它的叶子节点之间是有指针的，并且叶子节点会包含其他非叶子节点。也就是说，B+树上的数据都会在叶子节点上存在一份。**值得注意的是，MySQL的B+树里，叶子节点之间的指针是双向指针**。

# 2-Page的结构

是Innodb引擎里的一个概念，1个Page的大小默认是16KB。当MySQL从磁盘中读数据时，每一次读取都会读一个Page的大小到内存中；当MySQL写数据时，会先开辟1个Page大小的内存空间，将数据写入，然后写入磁盘。**也就是说这个Page是MySQL读取操作时的内存基础大小**。一个Page包含两个关键结构：UserRecord和PageDirectory，其中UserRecord存储的是**实际的行数据**。

# 3-为什么插入数据，会在UserRecord里排好序？

 乱序插入的情况下，查询插入结果会发现默认主键索引升序排序，其实是在插入之前，行数据就会根据主键索引在UserRecord里升序排好序了。为什么要这样设计呢？

![image](https://user-images.githubusercontent.com/48977889/179668496-4a36355d-c080-476a-87d5-de7c6266443f.png)

假设我先放id=4的数据，此时它在UserRecord的第一行，然后我再插入id=1的数据，它会排到最前面变成第一行，id=4的数据会变成第二行。以此类推假设现在前四行数据分别是id=1,id=2,id=4,id=8，然后这1页的数据被写入磁盘。

我需要查WHERE id = 3的话，MySQL先从磁盘中读取1页的数据，**因为插入时默认升序排序了，所以读取到的UserRecord也是升序排好序了（不用ORDER BY的话）**。MySQL先从第一行进行比对，发现3 != 1，于是找第二行，发现2 != 3，于是找到第三行，发现3 != 4并且3 < 4，也就是说后面的数据都是＞3的，那就没必要继续遍历下去了，直接返回查询结果为null。

如果插入的时候没有排好序，假设插入顺序为id=8,id=2,id=1,id=4。那么查询WHERE id = 3时，需要对UserRecord的整个链表进行遍历。

**也就是说，插入时默认排好序，能够提升查询的效率，避免不必要的UserRecord遍历。**

# 4-PageDirectory的作用

在知识点3的前提下，如果我要查询WHERE id = 10000的话，那还是需要从头遍历整个链表，如果这个链表比较长，效率也会变低。于是PageDirectory的作用就来了：

![image](https://user-images.githubusercontent.com/48977889/179671365-c5037e88-b814-4bb3-84be-fb2bd478d567.png)



页目录本身也是个顺序表，它将UserRecord按顺序分成了多组，每一组存储了这一组起始行数据的主键值。假设知识点3的前提下，将UserRecord按2的单位分成了2组，就会有两个页目录，这两个页目录的起始行分别是1和4。

此时我要查询WHERE id = 3，MySQL先根据3找到对应的页目录，此时找到起始行=1的页目录，上面也说了这个页目录是按2位单位划分的，也就是1这个页目录里最多对应2条数据。于是MySQL从起始行id=1里开始遍历查找id=3，只遍历2次，如果找到则返回，找不到那就说明不存在。

同理，如果找WHERE id = 10000，匹配页目录时只能找到起始行=4的页目录，于是MySQL从id=4开始遍历，遍历2次，很显然是没有的，于是返回不存在。

页目录的作用主要是采用【分段遍历】来替代【从头遍历】，属于是空间换时间的措施。

# 5-要避免乱序插入和物理删除

假设在知识点4的记录上，1页只能存4条数据，这时候我要插入id=5，会发生什么呢？

![image](https://user-images.githubusercontent.com/48977889/179673161-e3665f6b-de24-4ffb-b6da-d589e75c265a.png)

首先MySQL会新开一页，通过指针连接旧页，将id=5的数据放在旧页，将旧页id=8的数据放到新页，然后重新维护新页与旧页的页目录

**所以说频繁删除或乱序插入，会导致UserRecord和页目录不停地发生变更与重排序，这样维护的开销就很大了，所以尽量避免这种操作。**这也是为什么不用UUID当主键的原因，首先UUID长度比较长，影响UserRecord的行数，其次UUID是无序的。以下是规范使用后，页与页之间的数据：

![image](https://user-images.githubusercontent.com/48977889/179673811-56ee77e2-5222-48d3-921e-0cb76b38f65c.png)

# 6-二级页目录

其实这和OS的二级页表是相同的概念，假设现在MySQL存了4页的数据，分别如下：

![image](https://user-images.githubusercontent.com/48977889/179674781-4e36956e-15b6-45c9-a874-12c3bf1659fb.png)

先不管数据的不准确性，只看4页的页目录。假设我要找id=49的数据，MySQL先【从磁盘读】第1页到内存，发现第一页的页目录不满足id=49，于是从【从磁盘读】第2页到内存，发现还是不满足。于是【从磁盘读】第3页，同理再【从磁盘读】到第4页，哎发现第4页的页目录48满足了，于是从这里为起始点开始遍历寻找id=49的行记录。

这有个问题，为了找id=49，从磁盘里读了4次页出来遍历，这样又回到了知识点4开头的问题：遍历效率。于是MySQL抽象出一层【二级页目录】，将不同页的【起始页目录】放到一个新页，并且这个目录项有个指针指向所在页：

![image](https://user-images.githubusercontent.com/48977889/179675611-e4233c78-f2d2-495f-aae2-1bd973506b76.png)

有了这个二级页目录，找id=49的步骤就变成这样：

1. 先从磁盘读二级页目录。
2. 通过id=49遍历目录项，发现命中37目录项。
3. 通过37目录项，从磁盘取出第4页，从第4页开始遍历页目录，发现命中48目录项
4. 于是从48目录项为起点，开始遍历寻找id=49的行记录

可以看到，这个二级页目录首要避免了【多余的磁盘读取】，其次是【多余的页内遍历】（1-3页的页目录遍历）。

# 7-二级页目录能存多少数据呢？

二级页目录本质也是页，总大小也是16KB，里面存的主要是主键和指针。假设某张数据表的主键是int类型，那么1个目录项的大小是4B+6B（Innodb指针大小）= 10B。也就是说这张表的二级页最多能存 (16 * 1024 / 10)，大约是1638个目录项，1个目录项对应1页。假设每1行的数据大小是1KB，那么1页就能存16条数据，一个二级页目录针对这张表只能存1638 * 16 = 26208条记录。

# 8-三级页目录与主键索引的引出

对于MySQL来说，二级页目录就相当于一颗高度为2的B+树。如果基于知识点7，我对这张表插入第26209条数据呢？和超出页容量一样，二级页目录也会进行连接，产生【三级页目录】：

![image](https://user-images.githubusercontent.com/48977889/179900225-120da86a-23fe-42ec-8a28-63acfdbe84c2.png)

其实这个表的页就变成【高度为3的B+树】了，此时这个表的三级页目录能存放 1638 * 26208 = 42928704条记录。通过id查询记录的过程和二级页目录一样，只不过多加了一层罢了。

如果单表的数据不停地增加，页目录的层数也会增加，当数据超过42928704时又会产生“四级页目录”了，B+树的高度也随之变成4。**层数越高MySQL的查询效率越低，所以当【MySQL单表的数据量会引起四层页目录的生成】时，就该考虑分库分表策略了。**

# 9-MySQL的主键索引

MySQL的主键索引就是知识点8的结构：类B+树，只不过区别是 叶子节点存储【一级页目录项】指向的【一组数据行】，而不是【一级页目录】，并且叶子节点之间用双向指针连接。

![image](https://user-images.githubusercontent.com/48977889/179903269-0fd70279-1079-41ea-9668-9196d0398a6a.png)

如图所示，这是一个高度为3的主键索引。

最终找到id所在的一级页目录，通过id找到对应的目录项，再通过目录项遍历到该行数据。**注意通过主键索引找到的是整行数据。 **

因为这棵树的节点既包含索引数据又包含用户数据（两种数据的种类不一样），所以主键索引也被称为聚簇索引。

# 10-非主键索引与回表查询

为了方便，我就拿复合索引举例子，假设某表有5个int字段 a b c d e，其中a是主键索引，建立一个b,c,d复合索引：

![image](https://user-images.githubusercontent.com/48977889/179904645-2984b7ff-8d49-4bd0-ad02-789b8b5b746e.png)

注意，111，322指的b=1,c=1=d=1和b=3,c=2,d=2，其他同理。

和主键索引一样，非主键索引会多索引值进行升序排序，如果是复合索引则按复合顺序依次升序。区别是非主键索引的叶子节点存的是【K=索引值，V=主键值】的映射信息，而不是像主键索引那样直接存整行数据。毕竟修改了行数据后总不能将所有索引的“行数据”都改一遍吧，所以非主键索引没有存行数据。

当命中非主键索引，找到结果集的主键后，通过这个主键再去查主键索引，形成最终的结果集，这个过程就是回表查询。	

如果此时查WHERE c=1 AND d= 1 AND b=1，还会命中这个索引嘛？如果在MySQL5.7之前确实不会，因为它默认按条件顺序去匹配。5.7之后做了一个优化，只要【最终能满足最左前缀匹配原则】，即使查询条件乱序还是能命中索引。