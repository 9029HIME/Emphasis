# 前置概念

想了解Raft算法的原理，首先要明白以下概念：

1. 任期（term)：下面会讲到，反正每一个节点都会维护自己的term。
2. 随机时间：每个节点都有自己、且不同的随机时间，这个时间是“与主节点心跳超时”的时间。
3. 一共有3种节点类型，每个节点持有一种类型：
4. 主节点(master)：集群的老大
5. 候选节点(candidate)：有可能成为老大的节点
6. 跟随节点(follower)：普通节点

# Raft算法的执行过程

![image](https://user-images.githubusercontent.com/48977889/192942825-192d2438-3e05-4744-8fd5-5dd947953511.png)

现在初始化状态，所有节点都是follower，每个节点的term都是0。此时还没有主节点的诞生。集群中有3个节点：A、B、C，它们的超时时间分别是50ms、150ms、200ms，任期分别是0、0、0。

![image](https://user-images.githubusercontent.com/48977889/192943627-d8149129-db47-4975-915f-99aa1879430e.png)

因为没有主节点，所以三个节点都会等待超时，其中A节点最先超时，超时的节点会变成【候选者】节点，也就是A节点变成候选节点。候选节点会做三件事：给自己的term+1、给自己投一票、然后向其他节点（B、C）发起投票选举邀请。

![image](https://user-images.githubusercontent.com/48977889/192943828-0df8b2e7-d0fa-476e-8278-4cd9dad6acd9.png)

B和C收到邀请后，确定自己的投票，因为此时只有A一个候选节点，只能投A，A的投票邀请包含了A的term，于是B和C给A进行响应，告知投票给A，并且将自己的term改为和A一样。

![image](https://user-images.githubusercontent.com/48977889/192943972-97ad984e-7ff8-415c-8b95-6641031a91e2.png)

A发现自己的选票得到了大多数节点（2/n   +1)的认可，于是将自己认为主节点，A向其他节点发送心跳请求，维持主节点与其他节点之间的连接。此时集群的主节点选举完毕。在这里，我将此时定为“时间点T”

# 主节点宕机

如果在时间点T之后，A宕机呢？

1. 其他最先超时的节点B，会将自己定为候选节点，做出了和之前A一样的行为：term+1，给自己投一票、然后向其他节点（A、C）发起投票选举邀请。最终B节点选为主节点。
2. 因为A宕机了，此时A是收不到B的投票邀请，B会一直发一直发，直到A恢复。此时A收到B的邀请，发现B的term已经变为2了，也就是其他节点的term高于自己的term，于是A将自己降级为跟随节点，并持续和新主节点B保持心跳。

# 可视化网站

实际上Raft算法还有很多细节，比如A节点和B节点的超时时间很相似，导致产生两个候选节点，这时C会怎么处理？此时C会陆续收到A和B的投票邀请，谁先谁后要看网络延迟，加入C选择B当主节点，那么会给A和B都响应投票结果，B发现自己的票数最高，于是升级为主节点，此时A拿到C的选择，也会发现B的票数最高，于是也将B作为主节点看待。

还有一个问题，如果在时间点T之后，C节点因为网络故障，一直接收不到A的心跳，直到超时会怎么样？此时它也会将自己作为候选节点看待，重新发起投票邀请（假设这时候网络又通了），因为C的term已经+1了，所以很多跟随者会投C，此时C就成为新的主节点了。

除此之外还有很多细节，可以通过https://raft.github.io/这个网站，去模拟各种场景下，Raft算法是怎么做的。