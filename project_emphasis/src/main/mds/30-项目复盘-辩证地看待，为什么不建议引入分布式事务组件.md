# 前言

我们认为，Seata是项目早期的技术债（最初的产品是委托项目外包公司写的）。目前团队已经将 **去Seata化** 作为2023年的技术规划之一，围绕的核心思想是：不要分布式事务，但具体的方案还没确定，估计初步是以同步阻塞的方式落地。

# 观点

1. 分布式事务组件会引起 微服务 发生大规模地、组件之间的耦合。我们都知道，分布式事务组件主要有三个角色，RM（单次分布式事务的子事务）、TM（单次分布式事务）、TC（分布式事务协调者）。

2. TC作为整体的应用控制，是一个独立部署的组件。在日常开发过程中，以下单-扣库存这个场景为例，订单系统 和 库存系统都要接入Seata这个组件。Seata作为基础设施是不允许暴露的，本质并不是微服务的一部分，所以不在Gateway的范围内。

   Seata本质不属于微服务组件，所以不在Gateway内，但 Gateway内的微服务 需要 接入Gateway外的组件，**从架构设计角度看，这是不合理的**。

3. XA、AT、TCC、SAGA这四种模式，都有各自的缺点，使用不当会导致单次全局事务执行效率变低，特别是TCC，非常考验代码编写规范。

   对于单个服务来说，没有“银弹模式”。在实际生产环境中，往往会采用多重模式混合使用的策略。这种标准不明确、不统一的使用方式，无形之中增加了隐患、排查问题的难度。

# 如何规避

1. 不用分布式事务组件，采用MQ + 本地消息表的方式，实现分布式事务。

2. 不用分布式事务，可以考虑以下方案：

   1. 同步阻塞，以接口调用的方式，在 订单系统 调用 库存系统 的接口，库存没扣减完订单系统不返回结果，直至扣减成功或扣减失败。

      但是，要注意兜底补偿机制，比如扣减库存成功后下单失败，要及时释放库存。

   2. 异步调用，以MQ或者其他异步组件的方式，订单系统 调用 库存系统 的接口，然后定时轮询库存接口，查询扣库存结果。

      这种方案需要配合业务设计，允许软状态的存在，有点类似MQ + 本地消息表的方式。

# 一些补充

分布式一致性问题 会随着 调用层级的增加 而增加，比如A → B → C的一致性难度 会比 A → B → C → D → E的一致性难度更小。对于长链路的调用，可以考虑采用聚合器模式实现，比如A → BC → DE，目前采用的就是这种方案。
