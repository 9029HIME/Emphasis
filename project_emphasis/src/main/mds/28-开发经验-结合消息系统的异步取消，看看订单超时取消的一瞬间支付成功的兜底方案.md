# 消息系统的参考

在202211，消息系统上线了延时短信的功能，通过**key超时订阅（消息系统有自己的Redis，准确率还是比较高的，所以没用死信）**来完成延时功能，同时还支持通过唯一标识id来取消发送。这时不得不考虑一个场景：在发送短信的一刻，上游系统系统发起取消该怎么办？

先看看正常流程：

1. 接收到上游的延时短信请求。
2. 短信入库，标识为“未发送”。
3. 订阅key超时时间，等待Redis的通知。
4. key超时，消息系统收到通知，开始发送短信。

发送和取消是基于同一个partition进行，原则上是能保证 取消 在 发送之后收到。对于取消的发生时机，有以下情况：

1. 在1和2之间收到取消请求

   此时短信还未入库，通过一个异步线程池不断重试更新，直到超出重试阈值，并发送异常邮件告警（一般这种情况比较少发生）

2. 在2和4之间收到取消请求

   更新短信状态为“已取消”，最终在4.发送短信的时候，不会实际发送。

3. 在4.发送短信的一瞬间收到取消请求

   短信仍会成功发送，但会发送异常邮件告警，表示取消发送失败。

也就是说，在决定发送的一刻，上游系统系统发起取消，我们采用的是**取消失败**的处理方式，并发送异常告警，来进行人工兜底处理。毕竟短信是一种特殊的消息，它没有回滚机制，它不像邮件那样可以在用户未查看之前进行撤回，我们只能在之前的步骤尽可能地保证取消成功。

那对于可回滚的资源，又有什么解决方案呢？举一个例子：订单超时取消。

# 问题背景

关于订单超时取消这件事，已经有很多成熟的方案了，成熟度从低到高分别有：用户主动触发取消、暴力定时(1min甚至1s)任务取消、Redis的key超时事件订阅、RabbitMQ死信队列、RocketMQ的延时消息等等...

但是，不管是哪套方案，像这种涉及 **在下一个步骤执行之前，本步骤超时取消** 的业务场景，都会有一个临界状态：**在本步骤开始取消的那么一刻，下一个步骤开始执行**。落实到订单超时取消这个业务场景来看，就是 **订单在取消的那一刻，用户进行支付操作并支付成功**。
这种问题该如何进行兜底呢？我认为这是业务设计的范畴了，不是通过简单的技术能解决的。一般来说，业务设计主要有两种选择：最终下单失败、最终下单成功。