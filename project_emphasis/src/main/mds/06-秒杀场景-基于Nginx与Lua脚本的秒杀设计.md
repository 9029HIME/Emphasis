# 业务场景

为了引流，运营定了一个秒杀活动，选定了一些限量的秒杀商品，投放在外部渠道。用户点击进去后需要提交订单、支付等操作，提交订单成功就意味秒杀成功。

# 系统设计图

![55ea42e2c46f410a89e379d0b023d89](https://user-images.githubusercontent.com/48977889/193035029-e129a764-5b96-4eaf-be3c-b1340afc60b8.jpg)

说一下整体流程

0. 商品提前预热，将商品以sku-库存的k-v形式缓存到Redis中。
1. 用户提交下单，前端请求下单接口（此时不一定是接口了，也有可能是特定的地址）。
2. 请求到达Nginx后，通过lua脚本判断参数，并且通过前端传过来的sku参数，调用decr命令，获取减1后的库存值。
3. 如果库存值＜0，说明商品已经被抢完，此时lua就要回复“抢单失败”。
4. 如果库存值≥0，说明抢到商品了，这时候lua组装订单信息，返回给前端，此时订单状态为【创单中】，同时将订单发送到MQ（上图只是示例，不一定要用RocketMQ）。
5. 订单系统监听MQ，消费消息，处理提交订单流程，最终落库。
6. 前端不停地轮询系统，查询订单状态，最终读到【出单成功】，跳转到支付页面。

# 一些细节的考虑

1. 其实挡在最前面的不一定是Nginx + Lua，也可以是专门的【创单系统】，通过【创单系统】来操作redis、响应结果、写MQ。
2. 取消订单该如何处理？其实也可以基于lua脚本来实现，lua发送【取消订单】的消息给MQ，订单系统接收消息后，将数据库中的订单状态改为取消，然后将redis中的值incr。**不过要注意消息的有序性，防止业务悬挂**。
3. 订单超时该如何处理？同样的道理，在发送一条【订单消息】给MQ后，再发送一条【取消订单】的消息给MQ，消息的TTL为15min，利用死信队列的特性完成延时消息。不过这需要MQ支持死信队列，如Kafka就不支持。并且还要考虑支付成功后，接收到取消订单的消息该如何处理？其实很简单，通过SQL语句 SET 订单状态 = '取消' WHERE 订单号 = '订单号' AND 订单状态 = '未支付'即可。