# 存储

## 持久层

在Broker眼中，消息是否存储到磁盘 与 消息是否开启持久化没有直接关系。开启持久化的消息到达队列后会被fsync，并且在内存容量允许的情况下，这个消息还会在内存停留一段时间，这样消息被使用时就不用从磁盘获取了，这一点和Kafka使用Page Cache和磁盘是类似的。没有开启持久化的消息一般只保留在内存中，在内存空间不足时会fsync到磁盘，这样做是为了保证消息在被ack之前仍能够被Consumer消费。当然，不管是否开启持久化，消息被ack后就会被Broker删除。从消息的存储到删除，都是交给RabbitMQ的**持久层**完成。Kafka有稀疏索引和顺序写入，RabbitMQ有什么呢？

RabbitMQ的持久层可以分为两部分：rabbit_queue_index和rabbit_msg_store。rabbit_queue_index维护消息的落盘元数据，比如消息的存储位置、是否已被发送给Consumer，是否已被Consumer Ack，每个queue都有自己的rabbit_queue_index。而rabbit_msg_store只要以KV形式存储消息，它是Broker级别的、所有队列共享1个rabbit_msg_store。rabbit_msg_store还能被再细分为msg_store_persistent和msg_store_transient，前者负责持久化消息的持久化，重启后仍在。后者负责非持久化消息的持久化，重启后丢失。简单来说：

1. rabbit_queue_index:
   1. 队列级别。
   2. 维护消息的存储位置、是否已被发送给Consumer，是否已被Consumer Ack等信息。
2. rabbit_msg_store：
   1. 以KV方式存储消息
   2. msg_store_persistent：
      1. 负责持久化消息的持久化，Broker重启后消息仍在。
   3. msg_store_transient：
      1. 负责非持久化消息的持久化，Broker重启后消息丢失。

rabbit_queue_index和rabbit_msg_store可以在$RABBITMQ_HOME/var/lib/mnesia/rabbit@HOSTNAME/下找到，注意rabbit_msg_store会以msg_store_persistent和msg_store_transient的形式区分存储。

## 消息的存储选择

RabbitMQ允许消息被存储到rabbit_queue_index或rabbit_msg_store中，但只能选择其一，至于怎么选择交给queue_index_embed_msgs_below来配置，默认是4096Byte。当消息大小**（包括消息体、属性、headers的整体大小）**＞ 阈值时，存储在store，反之存储在index。

存储在index的好处显而易见，将index当作聚簇索引使用，减少回表查询store，但消息太大还存储在index会导致index膨胀，最终导致index定位效率低，所以还需要阈值来进行分流。